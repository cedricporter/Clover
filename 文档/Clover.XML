<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Clover</name>
    </assembly>
    <members>
        <member name="M:Clover.IO.CloverFileWriter.ReAllocateVertexID(Clover.VertexLayer)">
            <summary>
            重新分配顶点的id号
            </summary>
            <param name="vertexLayer"></param>
        </member>
        <member name="M:Clover.IO.CloverFileWriter.SaveVertexLayer(System.IO.FileStream,Clover.VertexLayer)">
            <summary>
            保存顶点层
            </summary>
            <param name="fs"></param>
            <param name="vertexLayer"></param>
        </member>
        <member name="M:Clover.FoldingSystem.UnionVertex(Clover.Face[])">
            <summary>
            将一堆面的周围的顶点找出并返回一个list
            </summary>
            <param name="faces"></param>
            <returns></returns>
        </member>
        <member name="M:Clover.FoldingSystem.CalculateTexcoord(Clover.Vertex,Clover.Edge)">
            <summary>
            计算顶点纹理坐标
            </summary>
            <param name="vertex"></param>
            <param name="edge"></param>
            <returns></returns>
        </member>
        <member name="M:Clover.FoldingSystem.CalculateTexcoord(Clover.Vertex,Clover.Edge,System.Double)">
            <summary>
            计算顶点纹理坐标
            </summary>
            <param name="vertex">需要计算纹理坐标的点</param>
            <param name="edge">该点所在的边</param>
            <param name = "length">该边根节点的总长度</param>>
        </member>
        <member name="M:Clover.FoldingSystem.FindEdgeByTwoVertexInAFace(Clover.Face,Clover.Vertex,Clover.Vertex)">
            <summary>
            在一个面中，通过两个顶点找到包含这两个顶点的边
            </summary>
            <param name="face"></param>
            <param name="v1"></param>
            <param name="v2"></param>
            <returns></returns>
        </member>
        <member name="M:Clover.FoldingSystem.CutFace(Clover.Face,Clover.Edge)">
            <summary>
            切割一个面为两个面
            </summary>
            <param name="face">要切割的面</param>
            <param name="edge">割线，不一定要在边层里面的边，只要两个端点的坐标在面的边上即可</param>
            <returns>被边引用的割线</returns>
        </member>
        <member name="M:Clover.FoldingSystem.UpdateFaceVerticesToLastedVersion(Clover.Face)">
            <summary>
            更新面的所有的顶点到在vertexLayer中最新的版本。
            </summary>
        </member>
        <member name="M:Clover.FoldingSystem.GetFoldingLine(Clover.Face,System.Windows.Media.Media3D.Point3D,System.Windows.Media.Media3D.Point3D)">
            <summary>
            获取折线
            </summary>
            <param name="pickedFace">选中的面</param>
            <param name="pickedPoint">选中的点</param>
            <param name="projectionPoint">投影点</param>
            <returns></returns>
        </member>
        <member name="M:Clover.FoldingSystem.GetFoldingLineOnAFace(Clover.Face,Clover.Edge)">
            <summary>
            找到折线穿过面的那条线段
            </summary>
            <param name="face">要测试的面</param>
            <param name="currentFoldingLine">当前的折线</param>
            <returns>对于测试面的折线</returns>
        </member>
        <member name="M:Clover.FoldingSystem.FoldingUpToPoint(Clover.Face,Clover.Vertex,System.Windows.Media.Media3D.Point3D,Clover.Edge)">
            <summary>
            直接折叠到投影点上
            </summary>
            <param name="pickedFace"></param>
            <param name="pickedVertex"></param>
            <param name="projectionPoint"></param>
        </member>
        <member name="M:Clover.FoldingSystem.TestMovedFace(Clover.Face,Clover.Face,Clover.Vertex)">
            <summary>
            测试要移动的面
            </summary>
            <param name="face">待测试的面</param>
            <param name="pickedFace">选中的面</param>
            <param name="pickedVertex">选中的点</param>
            <returns></returns>
        </member>
        <member name="M:Clover.FoldingSystem.TestFoldingLineCrossed(Clover.Face,Clover.Edge)">
            <summary>
            判断折线是否通过该平面
            </summary>
            <param name="face">当前判定平面</param>
            <param name="currentFoldingLine">折线亮点坐标</param>
            <returns></returns>
        </member>
        <member name="M:Clover.FoldingSystem.AddMovedFace(Clover.Vertex,Clover.Face,Clover.Edge)">
            <summary>
            判定移动的面
            </summary>
            <param name="pickedFace"></param>
            <param name="foldingLine"></param>
        </member>
        <member name="M:Clover.FoldingSystem.CloneAndUpdateVertex(Clover.Vertex)">
            <summary>
            克隆和更新一个新的顶点到VertexLayer
            </summary>
            <param name="v"></param>
        </member>
        <member name="M:Clover.FoldingSystem.RotateFaces(System.Collections.Generic.List{Clover.Face},Clover.Edge,System.Double)">
            <summary>
            旋转一个面表中除去折痕的所有点 
            </summary>
            <param name="beRotatedFaceList">待旋转的面表</param>
            <param name="foldingLine">折线</param>
            <param name="angle">角度</param>
        </member>
        <member name="M:Clover.CloverMath.IsTwoPointsEqual(System.Windows.Point,System.Windows.Point,System.Double)">
            <summary>
            判断平面上的两点是否相等
            </summary>
            <param name="p1">点P1</param>
            <param name="p2">点P2</param>
            <param name="threadhold">容许的误差值</param>
            <returns>返回true如果判断成立</returns>
            <author>Kid</author>
        </member>
        <member name="M:Clover.CloverMath.IsTwoPointsEqual(System.Windows.Media.Media3D.Point3D,System.Windows.Media.Media3D.Point3D,System.Double)">
            <summary>
            判断空间中的两点是否相等
            </summary>
            <param name="p1">点P1</param>
            <param name="p2">点P2</param>
            <param name="threadhold">容许的误差值</param>
            <returns>返回true如果判断成立</returns>
            <author>Kid</author>
        </member>
        <member name="M:Clover.CloverMath.IsPointInTwoPoints(System.Windows.Media.Media3D.Point3D,System.Windows.Media.Media3D.Point3D,System.Windows.Media.Media3D.Point3D,System.Double)">
            <summary>
            判断点p是否处在空间线段p1,p2上
            </summary>
            <param name="p">要判断的点</param>
            <param name="p1">线段的端点p1</param>
            <param name="p2">线段的端点p2</param>
            <param name="threadhold">容许的误差值</param>
            <returns>返回true如果判断成立</returns>
            <author>Kid</author>
        </member>
        <member name="M:Clover.CloverMath.IsPointInTwoPoints(System.Windows.Point,System.Windows.Point,System.Windows.Point,System.Double)">
            <summary>
            判断点p是否处在平面线段p1,p2上
            </summary>
            <param name="p">要判断的点</param>
            <param name="p1">线段的端点p1</param>
            <param name="p2">线段的端点p2</param>
            <param name="threadhold">容许的误差值</param>
            <returns>返回true如果判断成立</returns>
            <author>Kid</author>
        </member>
        <member name="M:Clover.CloverMath.IntersectionOfLineAndPlane(System.Windows.Media.Media3D.Point3D,System.Windows.Media.Media3D.Point3D,System.Windows.Media.Media3D.Vector3D,System.Windows.Media.Media3D.Point3D)">
            <summary>
            判断直线p1,p2
            </summary>
            <param name="p1">直线上的一点p1</param>
            <param name="p2">直线上的一点p2</param>
            <param name="N">平面的法向量</param>
            <param name="Pon">平面上的一点</param>
            <returns>交点</returns>
            <remarks>注意！该函数并不提供平行检测！</remarks>
            <author>Kid</author>
        </member>
        <member name="M:Clover.CloverMath.IntersectionOfLineAndFace(System.Windows.Media.Media3D.Point3D,System.Windows.Media.Media3D.Point3D,Clover.Face,System.Windows.Media.Media3D.Point3D@)">
            <summary>
            判断直线是否与一个face有交点，如果有，则在最后一个参数传出来。
            </summary>
            <param name="p1">直线上的点1</param>
            <param name="p2">直线上的点2</param>
            <param name="f"></param>
            <param name="v">结果传出</param>
            <returns></returns>
        </member>
        <member name="M:Clover.CloverMath.GetPerpendicularBisector(System.Windows.Point@,System.Windows.Point@)">
            <summary>
            求一线段的中垂线
            </summary>
            <param name="p1">线段的一个端点，计算完后会由该变量返回中垂线的一个端点</param>
            <param name="p2">线段的另一个端点，计算完后会由该变量返回中垂线的另一个端点</param>
            <author>Kid</author>
        </member>
        <member name="M:Clover.CloverMath.GetDistanceBetweenTwoSegments(Clover.Edge,Clover.Edge)">
            <summary>
            求两线段之间最短距离
            </summary>
            <param name="e1">线段1</param>
            <param name="e2">线段2</param>
            <returns></returns>
        </member>
        <member name="M:Clover.CloverMath.GetMidperpendicularInFace(Clover.Face,Clover.Vertex,Clover.Vertex,System.Windows.Media.Media3D.Vector3D@,System.Windows.Media.Media3D.Point3D@)">
            <summary>
            计算一个面中两点的中垂线，结果在参数从输出
            </summary>
            <param name="f"></param>
            <param name="po"></param>
            <param name="pd"></param>
            <param name="t">直线的方向向量</param>
            <param name="p">直线上的一点</param>
        </member>
        <member name="M:Clover.CloverMath.PerpProduct(System.Windows.Media.Media3D.Vector3D,System.Windows.Media.Media3D.Vector3D)">
            <summary>
            求补集
            </summary>
            <param name="v0"></param>
            <param name="v1"></param>
            <returns></returns>
        </member>
        <member name="M:Clover.CloverMath.GetIntersectionOfTwoSegments(Clover.Edge,Clover.Edge,System.Windows.Media.Media3D.Point3D@)">
            <summary>
            计算两线段之间的交点
            </summary>
            <param name="e1">线段1</param>
            <param name="e2">线段2</param>
            <param name="intersection"></param>
            <returns>0:不相交 1:相交且有唯一交点 2:线段覆盖在另一线段上</returns>
        </member>
        <member name="M:Clover.CloverMath.IsPointInArea(System.Windows.Media.Media3D.Point3D,Clover.Face)">
            <summary>
            判断一个3D点是否处在由points围成的平面内
            </summary>
            <param name="point">要检查的点</param>
            <param name="points">平面的边界</param>
            <returns>返回true如果点在平面内或平面边界上</returns>
            <author>kid</author>
        </member>
        <member name="M:Clover.CloverMath.CalculatePlaneAngle(Clover.Face,Clover.Face)">
            <summary>
            计算两个face的二面角
            </summary>
            <param name="f1"></param>
            <param name="f2"></param>
            <returns></returns>
        </member>
        <member name="M:Clover.CloverMath.IsTwoVectorTheSameDir(System.Windows.Media.Media3D.Vector3D,System.Windows.Media.Media3D.Vector3D,System.Boolean)">
            <summary>
            判断两个向量的方向
            </summary>
            <param name="v1"></param>
            <param name="v2"></param>
            <param name="rigorous">是否严格判断，这时仅当两向量同向时才返回true，反向以及其他情况都是返回false</param>
            <returns></returns>
        </member>
        <member name="M:Clover.CloverMath.IsIntersectionOfTwoFace(Clover.Face,Clover.Face)">
            <summary>
            判断两个face是否相交
            </summary>
            <param name="f1"></param>
            <param name="f2"></param>
            <returns></returns>
        </member>
        <member name="M:Clover.CloverMath.GetNearestPointOnSegment(System.Windows.Media.Media3D.Point3D,System.Windows.Media.Media3D.Point3D,System.Windows.Media.Media3D.Point3D)">
            <summary>
            返回线段上离指定点最近的点
            </summary>
            <param name="p">指定点</param>
            <param name="p1">线段的一段</param>
            <param name="p2">线段的另一端</param>
            <param name="nearestPoint">返回最近的点</param>
            <returns></returns>
        </member>
        <member name="M:Clover.CloverMath.IsTwoFaceConected(Clover.Face,Clover.Face)">
            <summary>
            判断两个面是否相连,即有无公共边
            </summary>
            <param name="f1"></param>
            <param name="f2"></param>
            <returns></returns>
        </member>
        <member name="M:Clover.CloverMath.AreTwoPointsSameWithDeviation(System.Windows.Media.Media3D.Point3D,System.Windows.Media.Media3D.Point3D)">
            <summary>
            判断两个点是否是同一个位置
            </summary>
            <param name="p1"></param>
            <param name="p2"></param>
            <returns></returns>
        </member>
        <member name="T:Clover.IO.FileParser">
            <summary>
            Clover文件分析器，分析方式和编译器中的语法分析过程类似
            采用自顶向下的分析方法。
            </summary>
        </member>
        <member name="M:Clover.Utility.UpdateWorlCameMat">
            <summary>
            当镜头缩放时，更新由世界到镜头的矩阵
            </summary>
        </member>
        <member name="M:Clover.Utility.UpdateProjViewMat(System.Double,System.Double)">
            <summary>
            当窗口大小发生改变时，更新视口投影矩阵
            </summary>
        </member>
        <member name="M:Clover.Utility.UpdateTo2DMat">
            <summary>
            更新3d到2d矩阵
            </summary>
        </member>
        <member name="P:Clover.Utility.WorlCameMat">
            从世界坐标系转换到摄像机坐标系的矩阵
        </member>
        <member name="P:Clover.Utility.ProjViewMat">
            投影矩阵
        </member>
        <member name="T:Clover.ShadowSystem">
            <summary>
            影子，用于恢复折纸数据结构
            </summary>
        </member>
        <member name="M:Clover.ShadowSystem.Snapshot(Clover.SnapshotNode)">
            <summary>
            拍快照
            </summary>
        </member>
        <member name="M:Clover.ShadowSystem.Undo">
            <summary>
            撤销
            </summary>
        </member>
        <member name="M:Clover.ShadowSystem.Redo">
            <summary>
            重做
            </summary>
        </member>
        <member name="F:Clover.ShadowSystem.originFaceList">
            <summary>
            进入折叠模式前的叶子节点表，用于恢复
            </summary>
        </member>
        <member name="M:Clover.ShadowSystem.SaveVertices(System.Collections.Generic.List{Clover.Vertex})">
            <summary>
            保存一些顶点的历史到vertex layer
            </summary>
            <param name="vertices"></param>
        </member>
        <member name="M:Clover.ShadowSystem.SaveOriginVertices">
            <summary>
            为所有顶点保存历史记录
            </summary>
        </member>
        <member name="M:Clover.ShadowSystem.SaveOriginState">
            <summary>
            保存到原始叶节点表
            </summary>
            <param name="leaves">当前的叶子</param>
            <remarks>
            当撤销的时候，只需将originFaceList里面的face的孩子都清空就可以还原面树了。
            </remarks>
        </member>
        <member name="M:Clover.ShadowSystem.Revert">
            <summary>
            还原到originLeaves
            </summary>
        </member>
        <member name="M:Clover.ShadowSystem.CheckUndoTree">
            <summary>
            检查Undo完了有没有新的snapshot，
            有的话，删除所有的后续状态
            </summary>
        </member>
        <member name="M:Clover.ShadowSystem.RevertTailVertex">
            <summary>
            删除尾部多余的顶点
            </summary>
        </member>
        <member name="M:Clover.ShadowSystem.ClearTransparentFaces">
            <summary>
            删除所有的半透明面
            </summary>
        </member>
        <member name="M:Clover.ShadowSystem.CreateTransparentFace(Clover.Face)">
            <summary>
            创建半透明面
            </summary>
            <param name="face"></param>
        </member>
        <member name="P:Clover.ShadowSystem.OperationLevel">
            当前level
        </member>
        <member name="P:Clover.ShadowSystem.SnapshotList">
            用以保存Snapshot
        </member>
        <member name="F:Clover.Visual.VisualElementFactory.box">
            <summary>
            容器 
            </summary>
        </member>
        <member name="F:Clover.Visual.VisualElementFactory.transformGroup">
            <summary>
            变换
            </summary>
        </member>
        <member name="M:Clover.Visual.VisualElementFactory.GetState">
            <summary>
            获取当前视觉元素的状态
            </summary>
            <returns></returns>
        </member>
        <member name="M:Clover.Visual.VisualElementFactory.Start">
            <summary>
            使视觉元素处于FadeIn状态
            </summary>
        </member>
        <member name="M:Clover.Visual.VisualElementFactory.End">
            <summary>
            使视觉元素处于FadeOut状态
            </summary>
        </member>
        <member name="M:Clover.EdgeTree.GetNode">
            <summary>
            通过一些条件索引所有符合条件的边界点
            </summary>
            <returns></returns>
        </member>
        <member name="M:Clover.EdgeLayer.UpdateTree(Clover.Edge,Clover.Vertex)">
            <summary>
            一条边分割成两条边
            </summary>
            <param name="parentEdge"></param>
            <param name="cutVertex"></param>
        </member>
        <member name="M:Clover.EdgeLayer.Update">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:Clover.IO.IOController.ReadCloverFile(System.String)">
            <summary>
            从硬盘读入一个Clover工程
            </summary>
        </member>
        <member name="M:Clover.IO.IOController.WriteCloverFile(System.String)">
            <summary>
            将一个Clover工程写入硬盘
            </summary>
        </member>
        <member name="M:Clover.IO.IOController.ExportTexture(System.String)">
            <summary>
            导出带折线提示的折纸图片
            </summary>
        </member>
        <member name="M:Clover.IO.IOController.ExportScript(System.String)">
            <summary>
            导出折叠脚本
            </summary>
        </member>
        <member name="F:Clover.FacecellTreeState.Undoing">
            正常模式，Leaves返回真正的叶节点
        </member>
        <member name="T:Clover.FacecellTree">
            <summary>
            面树，保存着所有的面，包括历史上存在过的面
            </summary>
        </member>
        <member name="F:Clover.FacecellTree.currentState">
            当前状态，
        </member>
        <member name="M:Clover.FacecellTree.UpdateLeaves(Clover.Face)">
            <summary>
            更新叶节点
            </summary>
            <param name="oldFace">改变了的节点</param>
            <remarks>如果输入一个面，则将这个面移除并将他的两个孩子加到叶节点表。否则重建整棵树。</remarks>
        </member>
        <member name="M:Clover.FacecellTree.Travel(Clover.Face)">
            <summary>
            后续遍历
            </summary>
            <param name="r">根节点</param>
            <remarks>请在调用Travel前清空leaves！</remarks>
        </member>
        <member name="P:Clover.FacecellTree.Leaves">
            <summary>
            返回所有叶节点，每次自动更新，如果要更高的运行效率，可以拆成另外两个函数
            </summary>
        </member>
        <member name="P:Clover.FacecellTree.RealLeaves">
            <summary>
            真正的叶节点
            </summary>
        </member>
        <member name="T:Clover.FaceGroupLookupTable">
            <summary>
            group查询表，可以得到所有的group。
            </summary>
        </member>
        <member name="M:Clover.FaceGroupLookupTable.#ctor(Clover.Face)">
            <summary>
            构造第一个面的时候初始化。
            </summary>
            <param name="f"></param>
        </member>
        <member name="M:Clover.FaceGroupLookupTable.GetGroup(Clover.Face)">
            <summary>
            得到面所在的分组,如果获取失败返回null,当获取失败时检查一下是否忘记add了。
            </summary>
            <param name="f"></param>
            <returns></returns>
        </member>
        <member name="M:Clover.FaceGroupLookupTable.AddFace(Clover.Face)">
            <summary>
            往lookuptable中加入face，会自动匹配加入group中或新增group。
            否则强制新建一个group
            </summary>
            <param name="f"></param>
        </member>
        <member name="M:Clover.FaceGroupLookupTable.RemoveFace(Clover.Face)">
            <summary>
            删除looktable的某个face，不存在则会失败返回false
            </summary>
            <param name="f"></param>
            <returns></returns>
        </member>
        <member name="M:Clover.FaceGroupLookupTable.SortGroup">
            <summary>
            重新给group里面的东西排序
            </summary>
        </member>
        <member name="M:Clover.FaceGroupLookupTable.UpdateGroup">
            <summary>
            当有可能一个group的face不再属于同一个group时候调用，强制更新。
            </summary>
        </member>
        <member name="M:Clover.FaceGroupLookupTable.RemoveRedundantFaceGroup">
            <summary>
            刷新table中的列表，删除空的组
            </summary>
        </member>
        <member name="M:Clover.FaceGroupLookupTable.UpdateTableAfterFoldUp(System.Boolean)">
            <summary>
            foldup后对lookuptable进行更新和排序
            </summary>
            <param name="IsDefaultDir">是否按照默认方向折叠，默认方向是面向用户，即摄像机的方向</param>
            <returns></returns>
        </member>
        <member name="T:Clover.FaceLayer">
            <summary>
            面层的抽象
            </summary>
        </member>
        <member name="M:Clover.FaceLayer.UpdateLoopupTable">
            <summary>
            更新面的查询表，查询表里面将同一个平面的面组合在一个组里面。
            </summary>
        </member>
        <member name="M:Clover.FaceLayer.Update(System.Collections.Generic.List{Clover.Edge},System.Double)">
            <summary>
            这里有问题，要修改
            </summary>
            <param name="edges"></param>
            <param name="rotDegree"></param>
        </member>
        <member name="T:Clover.App">
            <summary>
            App.xaml 的交互逻辑
            </summary>
            <summary>
            App
            </summary>
        </member>
        <member name="M:Clover.App.InitializeComponent">
            <summary>
            InitializeComponent
            </summary>
        </member>
        <member name="M:Clover.App.Main">
            <summary>
            Application Entry Point.
            </summary>
        </member>
        <member name="T:Clover.VertexLayer">
            <summary>
            Basic vertex structure.
            </summary>
        </member>
        <member name="M:Clover.VertexLayer.IsVertexExist(Clover.Vertex)">
            <summary>
            查找顶点是否在顶点列表中，若存在返回该顶点的索引，若不存在返回-1
            </summary>
            <param name="vertex"></param>
            <returns></returns>
        </member>
        <member name="M:Clover.VertexLayer.InsertVertex(Clover.Vertex)">
            <summary>
            插入一个全新的顶点，会建立一个新的顶点链表
            </summary>
            <param name="vertex"></param>
            <returns></returns>
        </member>
        <member name="M:Clover.VertexLayer.UpdateVertex(Clover.Vertex,System.Int32)">
            <summary>
            更新顶点
            </summary>
            <param name="vertex">插入在下标为index的顶点</param>
            <param name="index">这个顶点的索引</param>
            <remarks>下标越界会抛出异常</remarks>
        </member>
        <member name="M:Clover.VertexLayer.UpdateVertex(Clover.Vertex,Clover.Vertex)">
            <summary>
            更新节点
            </summary>
            <param name="oldVertex">要被更新的节点</param>
            <param name="newVertex">新的节点</param>
        </member>
        <member name="M:Clover.VertexLayer.DeleteNextVersionToEnd(Clover.Vertex)">
            <summary>
            将当前节点之后的版本删掉
            </summary>
            <param name="vertex"></param>
        </member>
        <member name="M:Clover.VertexLayer.DeleteThisVersionToEnd(Clover.Vertex)">
            <summary>
            把当前节点和之后的节点都删除
            </summary>
            <param name="vertex"></param>
        </member>
        <member name="M:Clover.VertexLayer.DeleteLastVersion(System.Int32)">
            <summary>
            删除最新版的节点
            </summary>
            <param name="index"></param>
        </member>
        <member name="T:Clover.IO.CloverFile">
            <summary>
            Clover工程文件
            至少包含以下信息：
            一颗完整的结构树
            当前视角
            当前纸张的纹理信息
            ……
            </summary>
        </member>
        <member name="T:Clover.CloverTreeHelper">
            <summary>
            提供一些使用的查询折纸结构的工具函数
            </summary>
        </member>
        <member name="M:Clover.CloverTreeHelper.UpdateFaceVerticesToLastedVersion(Clover.Face)">
            <summary>
            更新面的所有的顶点到在vertexLayer中最新的版本。
            </summary>
        </member>
        <member name="M:Clover.CloverTreeHelper.FindFacesFromVertex(System.Collections.Generic.List{Clover.Face},Clover.Vertex)">
            <summary>
            通过点来找面
            </summary>
            <param name="faceList">传入一个面表</param>
            <param name="vertex"></param>
            <returns>返回找到的面</returns>
        </member>
        <member name="M:Clover.CloverTreeHelper.IsFaceInGroup(Clover.Face,Clover.AbstractLayer.FaceGroup)">
            <summary>
            判断一个面是否在一个组中
            </summary>
            <param name="face"></param>
            <param name="group"></param>
            <returns></returns>
        </member>
        <member name="M:Clover.CloverTreeHelper.IsVertexInFace(Clover.Vertex,Clover.Face)">
            <summary>
            判断一个点是否在一个面中
            </summary>
            <param name="vervex"></param>
            <param name="face"></param>
            <returns></returns>
        </member>
        <member name="M:Clover.CloverTreeHelper.GetReferenceFaces(Clover.Vertex)">
            <summary>
            返回所有拥有该点的叶子面
            </summary>
            <param name="v"></param>
            <returns></returns>
        </member>
        <member name="M:Clover.CloverTreeHelper.GetSharedEdge(Clover.Face,Clover.Face)">
            <summary>
            返回两面的共边，如果没有则返回null
            </summary>
            <param name="face1"></param>
            <param name="face2"></param>
            <returns></returns>
        </member>
        <member name="M:Clover.CloverTreeHelper.FindBaseFace(Clover.AbstractLayer.FaceGroup)">
            <summary>
            返回一个组的基面，用以计算其他面的渲染偏差量
            </summary>
            <param name="group"></param>
        </member>
        <member name="T:Clover.SnapshotNodeKind">
            <summary>
            快照节点的类型
            </summary>
        </member>
        <member name="T:Clover.SnapshotNode">
            <summary>
            快照节点
            </summary>
        </member>
        <member name="T:Clover.MainWindow">
            <summary>
            MainWindow.xaml 的交互逻辑
            </summary>
            <summary>
            MainWindow
            </summary>
        </member>
        <member name="M:Clover.MainWindow.Window_Loaded(System.Object,System.Windows.RoutedEventArgs)">
            <summary>
            窗口初始化完毕后的操作
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="M:Clover.MainWindow.MainLoop(System.Object,System.EventArgs)">
            <summary>
            主循环
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="M:Clover.MainWindow.Window_Closing(System.Object,System.ComponentModel.CancelEventArgs)">
            <summary>
            窗口关闭时关闭所有子窗口
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="M:Clover.MainWindow.MenuBar_MouseLeftButtonDown(System.Object,System.Windows.Input.MouseButtonEventArgs)">
            <summary>
            移动窗体
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="M:Clover.MainWindow.Window_MouseMove(System.Object,System.Windows.Input.MouseEventArgs)">
            <summary>
            当鼠标在折纸视口上
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="M:Clover.MainWindow.Window_MouseDown(System.Object,System.Windows.Input.MouseButtonEventArgs)">
            <summary>
            当鼠标按下
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="M:Clover.MainWindow.Window_MouseDoubleClick(System.Object,System.Windows.Input.MouseButtonEventArgs)">
            <summary>
            双击
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="M:Clover.MainWindow.Window_MouseWheel(System.Object,System.Windows.Input.MouseWheelEventArgs)">
            <summary>
            改变折纸的距离
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="M:Clover.MainWindow.Window_SizeChanged(System.Object,System.Windows.SizeChangedEventArgs)">
            <summary>
            当窗口大小发生改变时……
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="M:Clover.MainWindow.MenuItem_Click(System.Object,System.Windows.RoutedEventArgs)">
            <summary>
            打开Clover文件
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="M:Clover.MainWindow.MenuItem_Click_1(System.Object,System.Windows.RoutedEventArgs)">
            <summary>
            保存Clover文件
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="M:Clover.MainWindow.InitializeComponent">
            <summary>
            InitializeComponent
            </summary>
        </member>
        <member name="M:Clover.Utilities.LinearEquation.Initialize(System.Int32,System.Double[0:,0:])">
            <summary>
            初始化类
            </summary>
            <param name="unkownnum">未知数的个数</param>
            <param name="g">线性方程的增广矩阵</param>
        </member>
        <member name="M:Clover.Utilities.LinearEquation.GetResult">
            <summary>
            获得方程解
            </summary>
            <returns></returns>
        </member>
        <member name="M:Clover.Utilities.LinearEquation.GaussianJordanElimination(System.Double[0:,0:])">
            <summary>
            高斯-约旦消元法；
            </summary>
            <param name="g"></param>
        </member>
        <member name="T:Clover.Properties.Resources">
            <summary>
              一个强类型的资源类，用于查找本地化的字符串等。
            </summary>
        </member>
        <member name="P:Clover.Properties.Resources.ResourceManager">
            <summary>
              返回此类使用的缓存的 ResourceManager 实例。
            </summary>
        </member>
        <member name="P:Clover.Properties.Resources.Culture">
            <summary>
              使用此强类型资源类，为所有资源查找
              重写当前线程的 CurrentUICulture 属性。
            </summary>
        </member>
        <member name="F:Clover.CloverController.edgeLayer">
            面层
        </member>
        <member name="F:Clover.CloverController.vertexLayer">
            边层
        </member>
        <member name="F:Clover.CloverController.mainWindow">
            点层
        </member>
        <member name="F:Clover.CloverController.renderController">
            你懂得
        </member>
        <member name="F:Clover.CloverController.shadowSystem">
            渲染层
        </member>
        <member name="F:Clover.CloverController.foldingSystem">
            影子
        </member>
        <member name="F:Clover.CloverController.faceGroupLookupTable">
            折叠系统
        </member>
        <member name="M:Clover.CloverController.UpdateFoldingLine(Clover.Face,System.Windows.Media.Media3D.Point3D,System.Windows.Media.Media3D.Point3D)">
            <summary>
            更新折线
            </summary>
            <param name="face"></param>
            <param name="pickedPoint"></param>
            <param name="projectionPoint"></param>
            <returns></returns>
        </member>
        <member name="M:Clover.CloverController.GenerateEdge(Clover.Face,Clover.Vertex,Clover.Vertex)">
            <summary>
            创建一条折线
            </summary>
            <param name="f"></param>
            <param name="pOriginal"></param>
            <param name="pDestination"></param>
            <returns>返回创建的折线，失败则返回null</returns>
        </member>
        <member name="M:Clover.CloverController.GetReferencedFaces(Clover.Vertex)">
            <summary>
            获取所有拥有该顶点的面
            </summary>
            <param name="vertex"></param>
            <returns></returns>
        </member>
        <member name="M:Clover.CloverController.CutFace(Clover.Face,Clover.Edge)">
            <summary>
            当割点在两条边上时，切割一个面为两个面
            </summary>
            <param name="oldFace"></param>
            <param name="leftChild"></param>
            <param name="rightChild"></param>
            <param name="edge"></param>
        </member>
        <member name="F:Clover.CloverController.affectedFaceList">
            <summary>
            当前都影响的面，在拖动的过程中需要实时计算，因为随时会有新的受影响
            的产生或者老的受影响的面被移除。
            </summary>
        </member>
        <member name="M:Clover.CloverController.StartFoldingModel(System.Collections.Generic.List{Clover.Face})">
            <summary>
            开始折叠模式
            </summary>
            <param name="faces">需要折叠的面</param>
            <remarks>
            首先保存原始面树的叶子。
            当撤销的时候，只需将originFaceList里面的face的孩子都清空就可以还原面树了。
            对于边树，我们将在当前叶子节点的面的边而不在originLeaves的边移除。
            </remarks>
        </member>
        <member name="M:Clover.CloverController.GetVertex(System.Int32)">
            <summary>
            通过索引获取点
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:Clover.CloverController.GetFoldingLine(Clover.Face,Clover.Vertex,Clover.Vertex)">
            <summary>
            获取一个面的折线
            </summary>
            <param name="face"></param>
            <param name="originVertex"></param>
            <param name="newVertex"></param>
            <returns></returns>
        </member>
        <member name="M:Clover.CloverController.DetermineFoldingUpConditionEstablished(Clover.Face,Clover.Vertex,System.Windows.Media.Media3D.Point3D,Clover.Edge@)">
            <summary>
            测试FoldingUp成立条件
            </summary>
            <param name="pickedFace"></param>
            <param name="originVertex"></param>
            <param name="projectionPoint"></param>
            <param name="foldingLine"></param>
            <returns></returns>
        </member>
        <member name="M:Clover.CloverController.JudgeCutAnotherFace(Clover.Face,System.Collections.Generic.List{Clover.Face},Clover.Vertex,System.Windows.Media.Media3D.Point3D,Clover.Edge)">
            <summary>
            判断本次拖拽是否有切割新的面
            </summary>
            <param name="foldingFaces"></param>
            <param name="originVertex"></param>
            <param name="projetionPoint"></param>
            <returns></returns>
        </member>
        <member name="M:Clover.CloverController.JudgeCutAnotherEdge(Clover.Face,Clover.Edge)">
            <summary>
            判断是否有切割其他的边
            </summary>
            <param name="pickedFace"></param>
            <param name="foldingLine"></param>
            <returns></returns>
        </member>
        <member name="M:Clover.CloverController.MoveToNewPosition(Clover.Vertex,System.Windows.Media.Media3D.Point3D,Clover.Face,Clover.Edge)">
            <summary>
            移动所有点到新的位置
            </summary>
            <param name="pickedFace"></param>
            <param name="foldingLine"></param>
        </member>
        <member name="M:Clover.CloverController.FoldingUpToAPoint(System.Collections.Generic.List{Clover.Face},Clover.Vertex,System.Windows.Media.Media3D.Point3D)">
            <summary>
            FoldingUp到一个投影点上
            </summary>
            <param name="pickedFace">选中的面</param>
            <param name="originVertex">选中的点</param>
            <param name="projectionPoint">投影点</param>
            <returns>折线边</returns>
        </member>
        <member name="M:Clover.CloverController.UpdateFaceGroupTable">
            <summary>
            
            </summary>
        </member>
        <member name="M:Clover.CloverController.FindFacesByVertex(Clover.Vertex)">
            <summary>
            通过点找面
            </summary>
            <param name="vertex"></param>
            <returns></returns>
        </member>
        <member name="M:Clover.CloverController.Update(System.Single,System.Single,Clover.Vertex,Clover.Face)">
            <summary>
            根据鼠标位移在每个渲染帧前更新结构
            </summary>
            <param name="xRel">鼠标的x位移</param>
            <param name="yRel">鼠标的y位移</param>
            <param name="faceList">折叠所受影响的面</param>
        </member>
        <member name="T:Clover.Vertex">
            <summary>
            抽象的点，里面包含渲染的点和其他信息
            </summary>
        </member>
        <member name="F:Clover.Vertex.renderPoint">
            逻辑层的坐标
        </member>
        <member name="F:Clover.Vertex.Index">
            渲染层的坐标
            
        </member>
        <member name="F:Clover.Vertex._u">
            在VertexLayer里面的索引，所有的孩子都有相同的index
        </member>
        <member name="T:Clover.Edge">
            <summary>
            抽象的边
            </summary>
        </member>
        <member name="P:Clover.Edge.Parent">
            <summary>
            设置父亲时不做任何事情
            </summary>
        </member>
        <member name="P:Clover.Edge.LeftChild">
            <summary>
            设置孩子时会将孩子的父亲置为自己
            </summary>
        </member>
        <member name="T:Clover.Face">
            <summary>
            抽象的面
            </summary>
        </member>
        <member name="M:Clover.Face.Flip">
            <summary>
            将一个面反过来
            </summary>
        </member>
        <member name="M:Clover.Face.Clone">
            <summary>
            返回一个新的面，但是他的边和点都不在折叠树里面。
            </summary>
            <returns></returns>
        </member>
        <member name="F:Clover.Face.startVertex1">
            <summary>
            两者决定这个面的法向量
            </summary>
        </member>
        <member name="M:Clover.Face.UpdateVertices">
            <summary>
            更新面的点，方便绘制时使用
            </summary>
        </member>
        <member name="M:Clover.Face.UpdateNormal">
            <summary>
            更行面的法向量
            </summary>
            <returns></returns>
        </member>
        <member name="T:Clover.Edge2D">
            <summary>
            边到2D的映射
            </summary>
        </member>
        <member name="F:Clover.Tool.ToolFactory.isVisualEnable">
            拾取点误差
        </member>
        <member name="F:Clover.Tool.ToolFactory.mainWindow">
            开启视觉元素
        </member>
        <member name="M:Clover.Tool.ToolFactory.ExcuteHitTest(System.Object@)">
            <summary>
            执行ray scene query，调用其他函数完成拾取判断。
            </summary>
            <returns>拾取到的CloverElement。如果没拾取到，返回null</returns>
        </member>
        <member name="M:Clover.Tool.ToolFactory.onMove">
            <summary>
            鼠标移动时的逻辑
            </summary>
        </member>
        <member name="M:Clover.Tool.ToolFactory.onPress">
            <summary>
            鼠标左键点击时的逻辑
            </summary>
        </member>
        <member name="M:Clover.Tool.ToolFactory.onDoubleClick">
            <summary>
            鼠标双击
            </summary>
        </member>
        <member name="M:Clover.Tool.ToolFactory.onIdle">
            <summary>
            主循环
            </summary>
        </member>
        <member name="T:Clover.IO.CloverFileLoader">
            <summary>
            Clover文件读取器
            </summary>
        </member>
        <member name="F:Clover.MaterialController.width">
            材质垂直分辨率
        </member>
        <member name="F:Clover.MaterialController.thickness">
            材质水平分辨率
        </member>
        <member name="F:Clover.MaterialController.frontMaterial">
            线条粗细
        </member>
        <member name="M:Clover.MaterialController.GetFrontShadow">
            <summary>
            获取纸张正面的半透明材质
            </summary>
            <returns></returns>
        </member>
        <member name="M:Clover.MaterialController.GetBackShadow">
            <summary>
            获取纸张背面的半透明材质
            </summary>
            <returns></returns>
        </member>
        <member name="M:Clover.MaterialController.UpdateFrontMaterial(System.Windows.Media.Media3D.DiffuseMaterial)">
            <summary>
            更新纸张正面的纹理
            </summary>
            <param name="mat"></param>
            <returns></returns>
        </member>
        <member name="M:Clover.MaterialController.UpdateBackMaterial(System.Windows.Media.Media3D.DiffuseMaterial)">
            <summary>
            更新纸张背面的纹理
            </summary>
            <param name="mat"></param>
            <returns></returns>
        </member>
        <member name="M:Clover.MaterialController.RebuildFoldLinesToPrev">
            <summary>
            根据ShadowSystem当前的堆栈重绘所有折线至上个版本
            </summary>
        </member>
        <member name="M:Clover.MaterialController.RebuildFoldLinesToNext">
            <summary>
            根据ShadowSystem当前的堆栈重绘所有折线至下个版本
            </summary>
        </member>
        <member name="M:Clover.MaterialController.MergeFrontTexture">
            <summary>
            返回合并过后的正面纹理
            </summary>
            <returns></returns>
        </member>
        <member name="M:Clover.MaterialController.MergeBackTexture">
            <summary>
            返回合并过后的背面纹理
            </summary>
            <returns></returns>
        </member>
        <member name="M:Clover.MaterialController.AddFoldingLine(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            添加折线
            </summary>
            <param name="u0"></param>
            <param name="v0"></param>
            <param name="u1"></param>
            <param name="v1"></param>
        </member>
        <member name="M:Clover.MaterialController.AddFrontFoldingLine(System.Windows.Point,System.Windows.Point)">
            <summary>
            在折纸的正面添加一条折线
            </summary>
            <param name="p0"></param>
            <param name="p1"></param>
        </member>
        <member name="M:Clover.MaterialController.AddBackFoldingLine(System.Windows.Point,System.Windows.Point)">
            <summary>
            在折纸的背面添加一条折线
            </summary>
            <param name="p0"></param>
            <param name="p1"></param>
        </member>
        <member name="M:Clover.MaterialController.UpdateFrontEdgeLayer">
            <summary>
            当分辨率改变时改变纸张的边的分辨率
            </summary>
        </member>
        <member name="M:Clover.MaterialController.UpdateBackEdgeLayer">
            <summary>
            当分辨率改变时改变纸张的边的分辨率
            </summary>
        </member>
        <member name="M:Clover.PaperSelector.LoadPaperTextures(System.String)">
            <summary>
            从指定路径扫描纹理文件
            </summary>
            <param name="path">扫描路径</param>
        </member>
        <member name="M:Clover.PaperSelector.OnPreviewEnter(System.Object,System.EventArgs)">
            <summary>
            高亮
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="M:Clover.PaperSelector.OnPreviewLeave(System.Object,System.EventArgs)">
            <summary>
            停止高亮
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="M:Clover.PaperSelector.OnPreviewClick(System.Object,System.EventArgs)">
            <summary>
            选择指定的图片作为纸张纹理
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="M:Clover.Tool.FoldTool.onSelectElement(System.Object)">
            <summary>
            选取元素
            </summary>
            <param name="element"></param>
        </member>
        <member name="M:Clover.Tool.FoldTool.onClick">
            <summary>
            鼠标单击，切换模式
            </summary>
        </member>
        <member name="M:Clover.Tool.FoldTool.onDrag(System.Object)">
            <summary>
            拖动元素
            </summary>
            <param name="element"></param>
        </member>
        <member name="M:Clover.Tool.FoldTool.FindNearestFace(System.Collections.Generic.List{Clover.Face})">
            <summary>
            寻找离我们最近的那个面
            </summary>
            <param name="faces"></param>
        </member>
        <member name="M:Clover.Tool.FoldTool.CalculateFoldingUpRotation">
            <summary>
            计算旋转量
            </summary>
            <returns></returns>
        </member>
        <member name="M:Clover.Tool.FoldTool.LockViewport(System.Boolean)">
            <summary>
            锁定或解锁视角
            </summary>
            <param name="islock"></param>
        </member>
        <member name="M:Clover.Tool.FoldTool.Get3DProjectionPoint">
            <summary>
            求2D到3D的投影点
            杨旭瑜提供
            </summary>
            <returns></returns>
        </member>
        <member name="M:Clover.Tool.FoldTool.UpdateFoldLine(Clover.Edge)">
            <summary>
            更新折线
            </summary>
            <param name="edge"></param>
        </member>
        <member name="M:Clover.Tool.FoldTool.exit">
            <summary>
            退出xx模式
            </summary>
        </member>
        <member name="M:Clover.Tool.FoldTool.EnterFoldingUp">
            <summary>
            进入Folding模式
            </summary>
        </member>
        <member name="M:Clover.Tool.FoldTool.ExitFoldingUp">
            <summary>
            退出Folding模式
            </summary>
        </member>
        <member name="M:Clover.Tool.FoldTool.UpdateFoldLineInfo(Clover.Edge)">
            <summary>
            更新折线提示
            </summary>
            <param name="edge"></param>
        </member>
        <member name="M:Clover.Tool.FoldTool.SpreadOut">
            <summary>
            如果有多层存在，将纸张散开以供用户选择
            </summary>
        </member>
        <member name="M:Clover.RenderController.ToGas(Clover.Face)">
            <summary>
            转变成半透明材质
            </summary>
            <param name="face"></param>
        </member>
        <member name="M:Clover.RenderController.ToSolid(Clover.Face)">
            <summary>
            转变成不透明材质
            </summary>
            <param name="face"></param>
        </member>
        <member name="M:Clover.RenderController.New(Clover.Face)">
            <summary>
            添加一个新面
            </summary>
            <param name="face"></param>
        </member>
        <member name="M:Clover.RenderController.Delete(Clover.Face)">
            <summary>
            删除指定面
            </summary>
            <param name="face"></param>
        </member>
        <member name="M:Clover.RenderController.DeleteAll">
            <summary>
            删除所有的面
            </summary>
        </member>
        <member name="M:Clover.RenderController.Update(Clover.Face)">
            <summary>
            更新一个已存在的面
            </summary>
            <param name="face"></param>
        </member>
        <member name="M:Clover.RenderController.UpdateAll">
            <summary>
            更新所有已存在的面
            </summary>
        </member>
        <member name="M:Clover.RenderController.NewMesh(Clover.Face)">
            <summary>
            根据传入的Face创建一个新MeshGeometry3D
            </summary>
            <param name="face"></param>
            <returns></returns>
        </member>
        <member name="M:Clover.RenderController.AntiOverlap">
            <summary>
            反重叠，让纸张散开
            </summary>
        </member>
        <member name="M:Clover.RenderController.AddFoldingLine(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            增加新的折线
            </summary>
            <param name="u0"></param>
            <param name="v0"></param>
            <param name="u1"></param>
            <param name="v1"></param>
            <param name="isUpdate"></param>
        </member>
        <member name="M:Clover.RenderController.UndrawFoldLine">
            <summary>
            撤销一步生成的折线
            </summary>
        </member>
        <member name="M:Clover.RenderController.RedrawFoldLine">
            <summary>
            根据ShadowSystem当前的堆栈重绘所有折线至下个版本
            </summary>
        </member>
        <member name="M:Clover.RenderController.GetFrontTexture">
            <summary>
            获取正面纹理
            </summary>
            <returns></returns>
        </member>
        <member name="M:Clover.RenderController.GetBackTexture">
            <summary>
            获取背面纹理
            </summary>
            <returns></returns>
        </member>
        <member name="M:Clover.RenderController.AddVisualInfoToVertex(Clover.Vertex)">
            <summary>
            为一个顶点添加提示信息
            </summary>
            <param name="v"></param>
        </member>
        <member name="M:Clover.RenderController.RenderAnimations">
            <summary>
            一些无法通过故事板实现，只能基于帧的动画
            </summary>
        </member>
        <member name="M:Clover.AbstractLayer.Magnet.PerformVertexAttach(System.Windows.Media.Media3D.Point3D,Clover.Face,System.Windows.Media.Media3D.Point3D@)">
            <summary>
            在给定的Face中寻找可吸附的边或点
            </summary>
            <param name="vertex"></param>
        </member>
        <member name="M:Clover.AbstractLayer.FaceSort.System#Collections#Generic#IComparer{Clover#Face}#Compare(Clover.Face,Clover.Face)">
            <summary>
            对组中的面进行排序
            </summary>
            <param name="f1"></param>
            <param name="f2"></param>
            <returns></returns>
        </member>
        <member name="T:Clover.AbstractLayer.FaceGroup">
            <summary>
            面组，里面的face都位于同一个plane上
            </summary>
        </member>
        <member name="M:Clover.AbstractLayer.FaceGroup.#ctor(Clover.Face)">
            <summary>
            group的构造函数，会计算一个group的法向量
            </summary>
            <param name="f"></param>
        </member>
        <member name="M:Clover.AbstractLayer.FaceGroup.AddFace(Clover.Face)">
            <summary>
            向一个组中增加面
            </summary>
            <param name="f"></param>
            <returns></returns>
        </member>
        <member name="M:Clover.AbstractLayer.FaceGroup.RemoveFace(Clover.Face)">
            <summary>
            删除某个面
            </summary>
            <param name="f"></param>
            <returns></returns>
        </member>
        <member name="M:Clover.AbstractLayer.FaceGroup.GetFaceList">
            <summary>
            得到面组
            </summary>
            <returns></returns>
        </member>
        <member name="M:Clover.AbstractLayer.FaceGroup.HasFace(Clover.Face)">
            <summary>
            检测某个face是存在group中
            </summary>
            <param name="f"></param>
            <returns></returns>
        </member>
        <member name="M:Clover.AbstractLayer.FaceGroup.SortFace">
            <summary>
            对面组中的面进行排序
            </summary>
        </member>
        <member name="M:Clover.AbstractLayer.FaceGroup.IsInSameGroup(Clover.Face,Clover.Face,System.Double)">
            <summary>
            判断两个面是否属于一个组
            </summary>
            <param name="f1"></param>
            <param name="f2"></param>
            <returns></returns>
        </member>
        <member name="M:Clover.AbstractLayer.FaceGroup.IsMatch(Clover.Face,System.Double)">
            <summary>
            判断一个面是否属于这个组
            </summary>
            <param name="f"></param>
            <returns></returns>
        </member>
    </members>
</doc>
